#!/bin/sh
#
# Copyright (c) 1993-2017 Easysoft Ltd. All rights reserved.
#
#


DRIVER="SQLSERVER"
PRODUCTLONG="Easysoft ODBC Driver for SQL Server"
PRODUCT="sqlserver"

#
# Clear the screen
#
if [ -x /usr/bin/clear ]; then
  /usr/bin/clear
fi
#
# Check we are in the dir untarred from the package.
#
if [ ! -x ./install ];then
  echo "You must run the install script from the directory created by"
  echo "untarring the main distribution file."
  exit 1
fi
INSTALLSCRIPTDIR=`pwd`
#
# Check the cwd is writeable as some tests create temporary files in the cwd.
#
if [ ! -w . ];then
  cat <<EOF

The current working directory is not writeable by you. Please correct this
and rerun the install script.

EOF
fi
#
# Output starting screen
#
cat <<EOF
Installation procedure for the $PRODUCTLONG

Copyright (C) 1993-2015 by Easysoft Limited.

Please read the file INSTALL.txt before attempting to install.

EOF
#
# Which echo?
#
if [ -x /bin/echo ];then
  ECHO="/bin/echo"
else
  if [ -x /usr/bin/echo ];then
    ECHO="/usr/bin/echo"
  else
    cat <<EOF
Cannot find the echo command
EOF
  exit 1
  fi
fi
#
# echo interprets backslash chrs by default? POSIX says no.
#
test=`$ECHO "fred\c"`
if [ "$test" = "fred\c" ];then
  oldecho="$ECHO"
  ECHO="$ECHO -e "
  test=`$ECHO "fred\c"`
  if [ "$test" != "fred" ];then
    if [ -x ./echo ];then
      ECHO=`pwd`/echo
    else
      cat <<EOF
echo command ($ECHO) does not interpret backslash characters.
You may see backslash c's when asked questions during this install.
You can safely ignore this except in Linux where you may need to
edit /etc/ld.so.conf to remove extra backslash n's from the lines added
by this script.
EOF
      ECHO="$oldecho"
    fi
  fi
fi
export ECHO			# allow child scripts to see ECHO
#
# Check the command line args
#
#
# Look for optional args
#
if [ $# -gt 0 ];then
  SKIP="$1"
else
  SKIP=""
fi
SKIPLICENSING=`$ECHO $SKIP | grep 'l' 2>/dev/null`
SKIPUNIXODBC=`$ECHO $SKIP | grep 'u' 2>/dev/null`
#
# Introduction and Licensing
#
if [ "$SKIPLICENSING" != "" ];then
  ./install_intro intro.txt skip
else
  ./install_intro intro.txt "" license.txt
fi
if [ $? -ne 0 ];then
  exit $?
fi
#
# Check we have the tools we need.
# ================================
#
./install_check_tools
if [ $? -ne 0 ];then
  exit $?
fi
# Need to do tr here as we need to decide what to use for upper->lower
if ( $ECHO "TeSt" | tr '[A-Z]' '[a-z]' 1>/dev/null 2>/dev/null )
then
  $ECHO "tr \c"
  lowctest=`$ECHO "TeSt" | tr '[A-Z]' '[a-z]'`
  if [ "$lowctest" != "test" ];then
    $ECHO
    $ECHO "Do not know how to use tr command to convert uppercase to lowercase"
  else
    LOWERCASE="tr '[A-Z]' '[a-z]'"
  fi
fi
if [ "$LOWERCASE" = "" ];then
  $ECHO "Trying dd"
  lowctest=`$ECHO "TeSt" | dd conv=lcase`
  if [ "$lowctest" != "test" ];then
    $ECHO "Do not know how to use dd command to convert uppercase to lowercase"
  else
    LOWERCASE="dd conv=lcase"
  fi
fi
if [ "$LOWERCASE" = "" ];then
  $ECHO "Trying sed"
  lowctest=`$ECHO "TeSt" | sed 'y/TES/tes/'`
  if [ "$lowctest" != "test" ];then
    $ECHO "Do not know how to use sed command to convert uppercase to lowercase"
    $ECHO "Cannot continue without a working tr, dd or sed command"
    exit 1
  else
    LOWERCASE="sed 'y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/'"
  fi
fi
export LOWERCASE
#
# If install_check_tools did not find OS tee but this distrib has a local one
# it will create usetee file.
#
if [ -r ./usetee ];then
  TEE="`pwd`/tee"
else
  TEE="tee"
fi
$ECHO "tee "
export TEE
$ECHO
$ECHO
#
# Set up vars used throughout.
# ============================
#
DEFAULT_PATH="/usr/local"    # default base install path
INST_SUBDIR="easysoft"       # dir under above IB installed in
INSTINFOFILE="${PRODUCT}_install.info" 
SUPPORT_EMAIL="support@easysoft.com"
export SUPPORT_EMAIL
INSTALLED_UNIXODBC=""        # installed unixODBC DM?
UNIXODBC_EXISTS=""           # existing unixODBC found - not installed
INSTALLED_LDSO_LINKS=""      # Updated ld.so (linux only)
TARSTDERROUTPUT="$INSTALLSCRIPTDIR/essqlservertarerr"
                             # stderr output from any tar extract
INSTALLWARNING="$INSTALLSCRIPTDIR/warnings" # Any warnings during install
#
# See what platform we are on
# ===========================
#
PLATFORM=`uname -s`
platform=`uname -s | $LOWERCASE`
export platform
osrelease=`uname -r`
osversions=`uname -v`
echo "Installation for $platform chosen"
#
# Platform specific differences
# =============================
#
# PIDARG is column is ps output where process ID shown
# PSARGS are the arguments to ps to generate process output that can be
# grepped for inetd's PID
#
# TARGIVESERR should be 1 if the tar on this platform actually works and
# returns an error state (>0) if tar fails. If the tar does not return
# error states then the install will try and examine stderr for errors -
# this is even more problematic as some tars send the -v output to stderr.
#
TARGIVESERR="0"
TARV2STDERR="0"
TARARGS="-xvf"
PIDARG="1"
TESTLINK="-L"
TESTEXISTS="-e"
if [ "$platform" = "irix64" ];then
  PSARGS="-ef"
  PIDARG="2"
  TARGIVESERR="1"
fi
if [ "$platform" = "aix" ];then
  PSARGS="ax"
fi
if [ "$platform" = "hp-ux" ];then
  PSARGS="-ef"
  PIDARG="2"
  TARGIVESERR="1"
fi
if [ "$platform" = "linux" ];then
  TARGIVESERR="1"
  PSARGS="ax"
fi
if [ "$platform" = "sunos" ];then
  PSARGS="-ef"
  PIDARG="2"
  TESTEXISTS="-r"
  TESTLINK="-h"
fi
if [ "$platform" = "sco_sv" ];then
  PSARGS="-ef"
  PIDARG="2"
  TESTEXISTS="-r"
fi
if [ "$platform" = "unixware" ];then
  PSARGS="-ef"
  PIDARG="2"
  TESTEXISTS="-r"
  TARARGS="-xvopf"
fi
if [ "$platform" = "unix_sv" ];then
  PSARGS="-ef"
  PIDARG="2"
  TESTEXISTS="-r"
fi
if [ "$platform" = "freebsd" ];then
  PSARGS="ax"
  TESTLINK="-h"
fi
if [ "$platform" = "sinix-n" ];then
  PSARGS="-ef"
  PIDARG="2"
  TESTEXISTS="-r"
  TESTLINK="-h"
  TARV2STDERR="1"
fi
if [ "$platform" = "osf1" ];then
  TARGIVESERR="1"
  PSARGS="-ef"
  PIDARG="2"
fi
if [ "$platform" = "darwin" ];then
  TARGIVESERR="1"		# sometimes!!
  PSARGS="ax"
  PIDARG="1"
fi
if [ "$platform" = "openunix" ];then
  PSARGS="-ef"
  PIDARG="2"
  TESTEXISTS="-r"
  TARARGS="-xvopf"
fi
if [ "$platform" = "interix" ];then
  TARGIVESERR="1"
  PSARGS="ax"
fi
export TESTEXISTS		# make TESTEXISTS available to child scripts
export TESTLINK			# make TESTLINK available to child scripts
export PIDARG
export PSARGS
export TARARGS
#
# Init
# ====
#
./install_init "$PRODUCTLONG"
if [ $? -ne 0 ];then
  exit $?
fi
#
# Platform specific checks
# ========================
#
# Linux - see what the highest version of libc installed is.
#
if [ "$platform" = "linux" ];then
  ./install_check_linux "$PRODUCTLONG" 1
    if [ $? != 0 ];then
        exit $?
    fi
elif [ "$platform" = "sunos" ]; then
  ./install_check_sunos "$PRODUCTLONG"
  if [ $? != 0 ];then
    exit $?
  fi
fi
#
# Check the package
# =================
#
# Check the tar file(s) exist (there may be more than one)
#  e.g. for multiple sub-packages
# Check the md5sum/sum is correct.
#
$ECHO "Press the return key to continue"
read press
$ECHO
$ECHO "Checking your package is OK..."
TARPATTERN="*.tar"
TARFILE_LIST=`$ECHO $TARPATTERN`
exist=`$ECHO $TARFILE_LIST`
#
# If the shell did not expand *.tar then there can't be any matching
# tar files in this dir.
#
if [ "$exist" = "$TARPATTERN" ]; then
  $ECHO "Cannot find any tar file packages matching \"$TARPATTERN\" in"
  $ECHO "the current directory. Are you sure you are running the install"
  $ECHO "script in the same directory the first tar file was unpacked to?"
  exit 1
fi
#
# Find out how many tar files we have and check each one.
#
TARFILES=`$ECHO $TARFILE_LIST | wc -w | awk '{print $1}'`
$ECHO "Found $TARFILES package(s)"
for TARFILE in $TARFILE_LIST
do
  $ECHO "Checking $TARFILE"
  if [ ! -r $TARFILE ];then
    $ECHO "Cannot find readable $TARFILE file"
    exit 1
  fi
  #
  # Try checking the tar file with md5sum.
  #
  checked=""
  if [ -r $TARFILE.md5sum ];then
    sh -c md5sum < ./install 2> /dev/null 1> /dev/null
    if [ $? -eq 0 ];then
	HASMD5SUM="y"
    fi
    if [ "$HASMD5SUM" = "y" ]
    then
      check=`md5sum $TARFILE | awk '{print $1}'`
      check2=`cat $TARFILE.md5sum`
      if [ "$check" = "$check2" ];then
  	checked="ok"
      else
  	checked="fail"
      fi
    else
      #$ECHO "Can't find md5sum on this machine - ignoring md5 checksum"
      $ECHO
    fi
  else
    #$ECHO "$TARFILE.md5sum not found - ignoring."
    $ECHO
  fi
  #
  # Try checking the tar file with sum.
  #
  if [ "$checked" = "" ];then
    if  [ -r $TARFILE.sum ];then
      if ( $ECHO "test" | sum 2> /dev/null 1> /dev/null )
      then
  	check=`sum $TARFILE | awk '{print $1}'`
  	check2=`cat $TARFILE.sum`
  	if [ "$check" = "$check2" ];then
  	  checked="ok"
  	else
  	  checked="fail"
  	fi
      else
  	$ECHO "Can't find sum on this machine"
      fi
    else
      $ECHO "$TARFILE.sum not found - ignoring,"
    fi
  fi
done
#
# Tar files not checksummed
# =========================
#
# If we failed to check a tar file then give the installer a chance to
# pull out of the installation.
#
if [ "$checked" = "" ];then
  $ECHO "Tarred packages not checked - can't find md5sum or sum."
  $ECHO "This package comes with a md5 message digest and a checksum."
  $ECHO "The installation was unable to check the package due to either"
  $ECHO "[1] failed to locate md5sum or sum."
  $ECHO "[2] failed to locate the md5 or checksum package files."
  $ECHO "It is not absolutely necessary to check your package in this way"
  $ECHO "and it is usually safe to continue."
  $ECHO
  $ECHO "Do you want to continue? (y/n) [n]: \c"
  answer="haha"
  while [ "$answer" != "" -a "$answer" != "n" -a "$answer" != "y" ]
  do
    read answer
    if [ "$answer" = "" ];then
      answer="n"
    fi
    if [ "$answer" != "y" ];then
      $ECHO "Installation terminated"
      exit 99
    fi
  done
fi
$ECHO "Package check - OK"
$ECHO
$ECHO "Press the return key to continue"
read press
#
# Check for root
# ==============
#
./install_check_root "$PRODUCTLONG" check_root.txt 1
if [ $? -ne 0 ];then
  exit $?
fi
#
#  Install Path
#  ============
#
cat <<EOF

You need to enter a location for the $PRODUCTLONG.
You should specify an existing directory under which directories called
"$INST_SUBDIR/$PRODUCT", "$INST_SUBDIR/lib", "$INST_SUBDIR/license",
"$INST_SUBDIR/etc". "$INST_SUBDIR/bin" and possibly "$INST_SUBDIR/unixODBC"
will be created.
You need write permission to the specified directory.
If the last directory in the path you specify does not exist the
installation will ask whether you would like it to be created.

Just hit the return key for the defaults.
EOF

#
# Request and create installation path
# ====================================
#
path=""
while [ "$path" = "" ]
do
  $ECHO "Enter a base install directory (q=quit) [ $DEFAULT_PATH ]: \c"
  read path
  if [ "$path" = "q" ];then
    $ECHO "Installation aborted at user request"
    exit 99
  fi
  if [ "$path" = "" ];then
    path="$DEFAULT_PATH"
  fi
  #
  # If the stem install dir (/usr/local default) does not exist create it.
  #
  if [ ! -d "$path" ]; then
    $ECHO "$path does not exist"
    $ECHO "Do you want to attempt to create it (y/n) [y]: \c"
    answer="hoho"
    while [ "$answer" != "" -a "$answer" != "n" -a "$answer" != "y" ]
    do
      read answer
      if [ "$answer" = "" ];then
        answer="y"
      fi
      if [ "$answer" = "y" ];then
        mkdir $path
	if [ $? -ne 0 ]
	then
          $ECHO "Failed to create $path"
	  path=""
	fi
      else
        path=""
      fi
    done
  elif [ ! -w "$path" -a ! -w "$path/$INST_SUBDIR" ]; then
    $ECHO "$path or $path/$INST_SUBDIR is not writeable"
    path=""
  fi
done
$ECHO
#
# We now make the <install_path>/$INST_SUBDIR tree.
# INST_SUBDIR may have more than one dir in it.
#
$ECHO "Making install dir \c"
echo "$path/$INST_SUBDIR" | sed 's,//,/,g'
flds=`echo "$INST_SUBDIR" | sed 's,/, ,g'`
base=`echo "$INST_SUBDIR" | awk -F/ '{print $NF}'`
stem=""
for dir in $flds
do
  xpath=`echo $path/$stem/$dir | sed 's,//,/,g'`
  if [ -d "$path/$stem/$dir" ];then
    $ECHO "$xpath already exists."
    $ECHO
    if [ "$dir" = "$base" ];then
      $ECHO "If you are reinstalling then it is wise to delete"
      $ECHO "$path/easysoft/${PRODUCT}"
      $ECHO "(as this will tell you if files are in use)."
      $ECHO
      $ECHO "If you are upgrading from a previous version then Easysoft strongly"
      $ECHO "recommend you remove the previous version first."
      $ECHO "However, you may continue if you wish."
      $ECHO ""
      $ECHO "Continue with install? (y/n) [y]: \c"
      answer="haha"
      while [ "$answer" != "" -a "$answer" != "n" -a "$answer" != "y" ]
      do
        read answer
        if [ "$answer" = "" ];then
          answer="y"
        fi
        if [ "$answer" != "y" ];then
          $ECHO "Installation terminated"
          exit 99
        fi
      done
    fi
  else
    if ( mkdir $xpath )
    then
      $ECHO "$xpath created"
    else
      $ECHO "Failed to create $xpath"
      exit 1
    fi
  fi
  stem="$stem/$dir"
done
#
# set the root in case of non standard install
#
EASYSOFT_ROOT=$path/$INST_SUBDIR
export EASYSOFT_ROOT
#
#  If not installed in the default place provide a symbolic link from the
#  default to the actual or shared object runpaths won't work.
#
if [ "$path" != "$DEFAULT_PATH" ];then
cat <<EOF

WARNING:
You have not chosen the default path for installing 
$PRODUCTLONG. For the built-in shared object run paths to work the 
installation needs to link $DEFAULT_PATH/$INST_SUBDIR to $path/$INST_SUBDIR.

EOF
  instsymlinkexists="n"
  answer="hoho"
  if [ "$TESTEXISTS" "$DEFAULT_PATH/$INST_SUBDIR" ];then
    $ECHO "but $DEFAULT_PATH/$INST_SUBDIR already exists"
    if [ "$TESTLINK" "$DEFAULT_PATH/$INST_SUBDIR" ];then
      instsymlinkexists="y"
      $ECHO "and is a symbolic link."
      $ECHO "Do you want to replace the symbolic link"
      $ECHO "$DEFAULT_PATH/$INST_SUBDIR ? (y/n) [y]: \c"
      while [ "$answer" != "" -a "$answer" != "n" -a "$answer" != "y" ]
      do
  	read answer
  	if [ "$answer" = "" ];then
  	  answer="y"
  	fi
      done
    else
      $ECHO "and is not a symbolic link."
      cat <<EOF
Please see the INSTALL,txt file for information on how this may be corrected
before continuing with this installation.
EOF
    fi
  else
    if [ ! "$TESTEXISTS" /usr/local ]; then
      if ( mkdir /usr/local )
      then
        $ECHO "/usr/local created"
      else
        $ECHO "Failed to create /usr/local"
      fi
    fi
    answer="y"
  fi
  if [ "$answer" = "y" ];then
    #
    # would like to use -sf (force) but some platforms do not have -f
    # so move existing link out of the way
    #
    if [ "$instsymlinkexists" = "y" ];then
      mv $DEFAULT_PATH/$INST_SUBDIR $DEFAULT_PATH/${INST_SUBDIR}_before_easysoft
    fi
    ln -s $path/$INST_SUBDIR $DEFAULT_PATH/$INST_SUBDIR
    if [ $? -ne 0 ]; then
      $ECHO "**WARNING** Failed to create easysoft symbolic link" | "$TEE" -a "$INSTALLWARNING"
      $ECHO "See INSTALL.txt file for information on how this may be corrected"
    fi
  fi
fi
#
# Record the version of driver installed
# Note this depends on the directory name.
#                                 
VERSION=`pwd | sed 's|.*\([0-9]\{1,2\}\)\.\([0-9]\{1,2\}\)\.\([0-9]\{1,2\}\)\.\([0-9]\{1,3\}\).*|\1.\2.\3.\4|'`
$ECHO "product: ${PRODUCTLONG}" >> $path/$INST_SUBDIR/$INSTINFOFILE
$ECHO "version: $VERSION" >> $path/$INST_SUBDIR/$INSTINFOFILE
$ECHO "date: \c" >> $path/$INST_SUBDIR/$INSTINFOFILE
date 2>/dev/null >> $path/$INST_SUBDIR/$INSTINFOFILE
#
# Install unixODBC DM
# ===================
#
# Give the installer a chance to install unixODBC
#
if [ "$SKIPUNIXODBC" != "" ];then
  $ECHO 
  $ECHO "Skipping unixODBC installation as requested"
  $ECHO
  $ECHO "Press the return key to continue"
  read press
else
  ./uodbc install unixodbc $path/$INST_SUBDIR "$PRODUCTLONG" $DRIVER 1 0
  answer=$?
  if [ $answer -gt 1 ];then
    $ECHO "Failed to install/locate unixODBC, uodbc returns $answer"
  else
    if [ $answer -eq 1 ];then
      INSTALLED_UNIXODBC="y"	# unixODBC DM was installed
      UNIXODBC_EXISTS="y"
    elif [ "$TESTEXISTS" ./uodbc_tmp ];then
      INSTALLED_UNIXODBC="n"      # it exists but we did not install it
      UNIXODBC_EXISTS="y"
    fi
  fi
fi
#
# Install driver
# ===========
#
# Unpack the common tar file
#
$ECHO
$ECHO "Press the return key to continue"
read press
cwd=`pwd`
cd $path/$INST_SUBDIR
$ECHO
$ECHO "Unpacking common parts of the distribution"
$ECHO
  > "$TARSTDERROUTPUT"
  if [ "$TARGIVESERR" = "1" ];then
    tar "$TARARGS" $cwd/all*.tar
  else
    tar "$TARARGS" $cwd/all*.tar 2>"$TARSTDERROUTPUT"
  fi
  sts=$?
  if [ "$TARV2STDERR"  = "1" ];then
    cat "$TARSTDERROUTPUT";
  fi
  tarerr="n"
  if [ $sts -ne 0 ];then
    $ECHO
    $ECHO "**WARNING**: Errors occurred during untar (all) operation" | "$TEE" -a "$INSTALLWARNING"
    $ECHO "Please check the following tar output before continuing:"
    $ECHO "****************************************"
    cat "$TARSTDERROUTPUT" | "$TEE" -a "$INSTALLWARNING"
    $ECHO "****************************************"
    tarerr="y"
  else
    output=`cat "$TARSTDERROUTPUT" 2>/dev/null | grep -v "blocksize" | grep -v "^x.*$"`
    if [ "$output" != "" ];then
      $ECHO
      $ECHO "**WARNING**: tar (all) returned successful but output text to stderr" | "$TEE" -a "$INSTALLWARNING"
      $ECHO "This is suspicious and should be investigated."
      $ECHO "Please check the following tar output before continuing:"
      $ECHO "****************************************"
      cat "$TARSTDERROUTPUT" | "$TEE" -a "$INSTALLWARNING"
      $ECHO "****************************************"
      tarerr="y"
    fi
  fi
  if [ "$tarerr" = "y" ];then
    answer="hoho"
    while [ "$answer" != "y" -a "$answer" != "n" ]
    do
      $ECHO "Warnings were output above. Continue? (y/n) [n]: \c"
      read answer
      if [ "$answer" = "" ];then
	answer="n"
      fi
      if [ "$answer" = "n" ];then
	$ECHO "Installation terminated"
        exit 99
      fi
    done
  fi
  > "$TARSTDERROUTPUT"
  
  INSTALLED_COMMON="y"
  cd "$cwd"
#
# Install Versioned Common Files
# ==============================
#
$ECHO
$ECHO "Press the return key to continue"
read press
./install_versioned "$path/$INST_SUBDIR"
if [ $? -ne 0 ];then
  $ECHO
  $ECHO "**ERROR** Failed to install all versioned files."  | "$TEE" -a "$INSTALLWARNING"
cat <<EOF
Please examine the above errors to determine the problem, fix and reinstall
or mail Easysoft support at $SUPPORT_EMAIL for assistance.

EOF
  answer="haha"
  while [ "$answer" != "y" -a "$answer" != "n" ]
  do
    $ECHO "Quit install (y/n) [y]: \c"
    read answer
    if [ "$answer" = "" ];then
      answer="y"
    fi
    if [ "$answer" = "y" ];then
      $ECHO "Installation terminated"
      exit 99
    fi
  done
fi

#
# Set LD_LIBRARY_PATH and LD_RUN_PATH so we can pick up unixODBC libs.
#
LDPATHLIBDIRS="$path/$INST_SUBDIR/lib"
if [ "$INSTALLED_UNIXODBC" != "" ];then
  LDPATHLIBDIRS="$LDPATHLIBDIRS:$path/$INST_SUBDIR/unixODBC/lib"
fi
LD_LIBRARY_PATH="$LD_LIBRARY_PATH:$LDPATHLIBDIRS"
export LD_LIBRARY_PATH
DYLD_LIBRARY_PATH="$DYLD_LIBRARY_PATH:$LDPATHLIBDIRS"
export DYLD_LIBRARY_PATH
LD_RUN_PATH="$LD_RUN_PATH:$LDPATHLIBDIRS"
export LD_RUN_PATH
SHLIB_PATH="$SHLIB_PATH:$LDPATHLIBDIRS"
export SHLIB_PATH
LIBPATH="$LIBPATH:$LDPATHLIBDIRS"
export LIBPATH
LDLIBDIRS=`echo $LDPATHLIBDIRS | sed 's/:/ /g'`
#
# Install ld.so paths
# ===================
#
# To finish off the install for Linux, we need to add
# entries to the /etc/ld.so.conf file for the dynamic linker. We need to be
# root for that. In all cases we at least need to install the easysoft/lib dir.
#
$ECHO
$ECHO "Press the return key to continue"
read press
./install_linkpaths "$PRODUCTLONG" $LDLIBDIRS
if [ $? -ne 0 ];then
  $ECHO "WARNING: Failed to install all link paths" | "$TEE" -a "$INSTALLWARNING"
fi
#
# Install esld.so.conf entries
#
./install_paths "$path/$INST_SUBDIR" $LDLIBDIRS
sts=$?
if [ $sts -ne 0 ];then
  $ECHO "WARNING: esld.so.conf file not updated successfully" | "$TEE" -a "$INSTALLWARNING"
  $ECHO "WARNING: install_paths returned $sts" | "$TEE" -a "$INSTALLWARNING"
fi
#
# Install driver under unixODBC DM
#
$ECHO "Press the return key to continue"
read press
cat <<EOF
Access to the $PRODUCTLONG is through the unixODBC Driver Manager.

The Driver Manager is told where to find $PRODUCTLONG
in the odbcinst.ini file.

EOF
file="drv_template_$$"
sed_target=`echo $EASYSOFT_ROOT | sed 's/\//\\\\\//g'`
sed 's/%EASYSOFT_ROOT%/'"$sed_target"'/' < drv_template > $file
./uodbc driver $file "$PRODUCTLONG" $DRIVER
if [ $? -ne 0 ]; then
  $ECHO "** Failed to install the $PRODUCTLONG for unixODBC **"
else
  $ECHO "Press the return key to continue"
  read press
    cat <<EOF

Data Sources are defined in the odbc.ini file.
This install will now create a sample data source called SQLSERVER_SAMPLE.

EOF
  ./uodbc dsn dsn_template "$PRODUCTLONG" "$DRIVER" 0
fi

file="drv_template_$$"
sed_target=`echo $EASYSOFT_ROOT | sed 's/\//\\\\\//g'`
sed 's/%EASYSOFT_ROOT%/'"$sed_target"'/' < drv_template_ssl > $file
./uodbc driver $file "$PRODUCTLONG" $DRIVER
if [ $? -ne 0 ]; then
  $ECHO "** Failed to install the $PRODUCTLONG for unixODBC **"
else
  $ECHO "Press the return key to continue"
  read press
    cat <<EOF

Data Sources are defined in the odbc.ini file.
This install will now create a sample data source called SQLSERVER_SAMPLE_SSL.

EOF
  ./uodbc dsn dsn_template_ssl "$PRODUCTLONG" "$DRIVER" 0
fi
#
# Checks for license file
#
cwd=`pwd`
./install_license "$PRODUCTLONG" $path/$INST_SUBDIR
cd $cwd

#
# offer to create a DSN
#

cwd=`pwd`
./sqlserver_create_dsn.sh $path/$INST_SUBDIR uodbc_tmp
cd $cwd

$ECHO
if [ "$TESTEXISTS" "$INSTALLWARNING" ];then
  output=`cat "$INSTALLWARNING" 2>/dev/null`
  if [ "$output" != "" ];then
    cat <<EOF
*******************************************************************
Warnings were output during this installation which may be found in the file
$INSTALLWARNING.
Please review these warnings as they could mean some part of this distribution
was not installed correctly. If you are unsure send a copy of the
$INSTALLWARNING file
to $SUPPORT_EMAIL along with details of the platform, operating system
and InterBase driver distribution.
*******************************************************************
EOF
    $ECHO "Press the return key to continue"
    read press
  fi
else
  $ECHO "** The $PRODUCTLONG has been installed successfully **"
fi
exit 0

